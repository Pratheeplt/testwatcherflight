const fs = require("fs");
const readline = require("readline");
const axios = require("axios");
const PushoverAPI = require("./PushoverAPI");
const clc = require("cli-color");
require("dotenv").config();

const ENV_FILE = ".env";
const TESTFLIGHT_BASE_URL = "https://testflight.apple.com/join/";

function loadEnv() {
  if (fs.existsSync(ENV_FILE)) {
    const content = fs.readFileSync(ENV_FILE, "utf8");
    return Object.fromEntries(
      content
        .split("\n")
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => line.split("=").map((part) => part.trim()))
    );
  }
  return {};
}

function saveEnv(env) {
  const content = Object.entries(env)
    .map(([key, value]) => `${key}=${value}`)
    .join("\n");
  fs.writeFileSync(ENV_FILE, content);
}

function saveURLs(urls) {
  const env = loadEnv();
  env.TESTFLIGHT_URLS = JSON.stringify(urls);
  saveEnv(env);
}

function loadURLs() {
  const env = loadEnv();
  return env.TESTFLIGHT_URLS ? JSON.parse(env.TESTFLIGHT_URLS) : [];
}

async function prompt(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) =>
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim());
    })
  );
}

async function verifyURL(url) {
  try {
    const response = await axios.get(url, { timeout: 5000 });
    if (response.status === 200) {
      console.log(
        clc.greenBright("\n‚úÖ Die URL ist g√ºltig und die Beta existiert.")
      );
      return true;
    }
  } catch (error) {
    const errorMessage =
      error.response && error.response.status === 404
        ? "\n‚ùå Fehler: Die Beta existiert nicht (404)."
        : "‚ùå Fehler: Konnte die Seite nicht √ºberpr√ºfen. Netzwerkproblem?";
    console.log(clc.redBright(errorMessage));
  }
  return false;
}

function displayMessage(message, type = "info") {
  const color =
    type === "success"
      ? clc.green
      : type === "error"
      ? clc.red
      : clc.magentaBright;
  console.log(color(message));
}

async function manageURLs(userKey, appToken) {
  let urls = loadURLs();

  while (true) {
    clearConsole();
    displayMessage("üìú Aktuelle TestFlight-URLs:", "info");
    urls.forEach((app, index) => {
      console.log(clc.yellow(`${index + 1}. ${app.name} - ${app.url}`));
    });

    console.log("\nüõ†Ô∏è Optionen:");
    console.log("1. üÜï Neue URL hinzuf√ºgen");
    console.log("2. üóëÔ∏è Existierende URL l√∂schen");
    console.log("3. ‚úÖ Fertig");

    const choice = await prompt(clc.cyan("W√§hle eine Option (1/2/3): "));

    if (choice === "1") {
      const name = await prompt(clc.cyan("\nApp-Name: "));
      let input = await prompt(clc.cyan("TestFlight-URL oder ID: "));
      let url = input.startsWith(TESTFLIGHT_BASE_URL)
        ? input
        : `${TESTFLIGHT_BASE_URL}${input}`;

      if (urls.some((app) => app.url === url)) {
        displayMessage("\n‚ùå Diese URL wurde bereits hinzugef√ºgt.", "error");
        displayMessage("üîô R√ºckkehr zum Hauptmen√º...", "info");
        await pause(3000);
        continue;
      }

      const isValid = await verifyURL(url);
      if (isValid) {
        urls.push({ name, url });
        saveURLs(urls);
        await sendPushoverNotification(
          userKey,
          appToken,
          "üÜï TestFlight-URL hinzugef√ºgt",
          `Die TestFlight-Beta f√ºr ${name} ist jetzt verf√ºgbar.\n\nURL: ${url}`
        );
        displayMessage("\nüì≤ Benachrichtigung gesendet.", "success");
        displayMessage("‚úÖ Neue URL hinzugef√ºgt.", "success");
        displayMessage("üîô R√ºckkehr zum Hauptmen√º...", "info");
        await pause(3000);
      } else {
        displayMessage(
          "‚ùå Die URL wurde nicht hinzugef√ºgt, da sie ung√ºltig ist.",
          "error"
        );
        displayMessage("üîô R√ºckkehr zum Hauptmen√º...", "info");
        await pause(3000);
      }
    } else if (choice === "2") {
      const index =
        parseInt(await prompt(clc.cyan("Nummer der zu l√∂schenden URL: ")), 10) -
        1;
      if (index >= 0 && index < urls.length) {
        displayMessage(
          `\nüóëÔ∏è L√∂sche: ${urls[index].name} - ${urls[index].url}`,
          "error"
        );
        await sendPushoverNotification(
          userKey,
          appToken,
          "üóëÔ∏è TestFlight-URL gel√∂scht",
          `Die TestFlight-Beta f√ºr ${urls[index].name} wurde gel√∂scht.\n\nURL: ${urls[index].url}`
        );
        displayMessage("\nüì≤ Benachrichtigung gesendet.", "success");
        urls.splice(index, 1);
        saveURLs(urls);
        displayMessage("‚úÖ URL gel√∂scht.", "success");
        displayMessage("üîô R√ºckkehr zum Hauptmen√º...", "info");
        await pause(3000);
      } else {
        displayMessage("‚ùå Ung√ºltige Auswahl.", "error");
        await pause(3000);
      }
    } else if (choice === "3") {
      break;
    } else {
      displayMessage("‚ùå Ung√ºltige Eingabe.", "error");
      await pause(3000);
    }
  }
}

async function sendPushoverNotification(userKey, appToken, title, message) {
  const pushover = new PushoverAPI(userKey, appToken);

  try {
    const response = await pushover.sendNotification(title, message, {
      priority: 0,
    });
    if (!response || response.status !== 1) {
      throw err;
    }
    return response;
  } catch (err) {
    throw err;
  }
}

async function configureEnvironment() {
  const env = loadEnv();
  displayMessage("\nüéâ Willkommen zum Setup!\n", "info");

  const questions = [
    {
      key: "OTP_SECRET",
      prompt:
        'Verschl√ºsselungsstring f√ºr das OTP (z.B. "768XuxTKWXKUPQ8fjfLxCtUQCVEKikq6")',
      defaultValue: "AendereDiesenString",
    },
    {
      key: "OTP_VALIDITY",
      prompt: 'G√ºltigkeitsdauer f√ºr das OTP in Minuten (z.B. "5" f√ºr 5 Min.)',
      defaultValue: "5 * 60 * 1000",
    },
    {
      key: "SETUP_FILE_NAME",
      prompt: "Name der Setup-Datei (Falls Du ihn angepasst hast)",
      defaultValue: "setup.js",
    },
    {
      key: "SERVER_FILE_NAME",
      prompt: "Name der Server-Datei (Falls Du ihn angepasst hast)",
      defaultValue: "index.js",
    },
    {
      key: "PORT",
      prompt: 'Port f√ºr den Server (z.B. "3000")',
      defaultValue: "3000",
    },
    {
      key: "HTTP_URL",
      prompt:
        "Auf welche Adresse ist der Webserver erreichbar? (z.B. http://localhost:3000)",
      defaultValue: "http://localhost:3000",
    },
    {
      key: "USER_AGENT",
      prompt: "User-Agent f√ºr Anfragen",
      defaultValue: "Testflight-Watcher/0.0.2 (Monitoring Script)",
    },
    {
      key: "PUSHOVER_PRIORITY",
      prompt:
        "Priorit√§t der Benachrichtigung bei freier Beta (Niedrigste = -2; Niedrige = -1; Normale = 0; Hohe = 1; Kritische = 2)",
      defaultValue: "1",
    },
    {
      key: "CHECK_INTERVAL",
      prompt:
        "In welchem Abstand soll das Script nach einem neuen Platz pr√ºfen in Sekunden (z.B. 30)",
      defaultValue: "30",
    },
  ];

  for (const { key, prompt: question, defaultValue } of questions) {
    if (env[key]) {
      displayMessage(
        `‚è© √úberspringe: ${key} (bereits gesetzt: ${env[key]})`,
        "info"
      );
      continue;
    }

    let currentValue = defaultValue;
    const answer = await prompt(
      clc.cyan(`${question} [Standard: ${currentValue}]: `)
    );

    if (key === "OTP_VALIDITY") {
      const minutes = parseFloat(answer || "5");
      currentValue = `${minutes} * 60 * 1000`;
    } else {
      currentValue = answer || currentValue;
    }

    env[key] = currentValue;
    saveEnv(env);
  }

  saveEnv(env);
  displayMessage("\nüìÇ Standard-Konfiguration gespeichert.", "success");
}

(async () => {
  const env = loadEnv();
  await configureEnvironment();

  if (!env.PUSHOVER_USER_KEY || !env.PUSHOVER_APP_TOKEN) {
    env.PUSHOVER_USER_KEY = await prompt(
      clc.cyan("\nPushover-Benutzer-Schl√ºssel: ")
    );
    env.PUSHOVER_APP_TOKEN = await prompt(clc.cyan("Pushover-API-Token: "));

    let testApiSuccess = false;
    while (!testApiSuccess) {
      const testApi = await prompt(
        clc.yellow("M√∂chtest Du die Pushover-Verbindung testen? (") +
          clc.green("ja") +
          clc.yellow("/") +
          clc.red("nein") +
          clc.yellow("): ")
      );
      if (testApi.toLowerCase() === "ja") {
        try {
          await sendPushoverNotification(
            env.PUSHOVER_USER_KEY,
            env.PUSHOVER_APP_TOKEN,
            "Pushover-Verbindung",
            "Die Pushover-API ist erfolgreich konfiguriert!"
          );
          testApiSuccess = true;
          displayMessage(
            "‚úÖ Die Verbindung zu Pushover war erfolgreich!",
            "success"
          );
          saveEnv(env);
          displayMessage(
            "\n\nüìÇ Pushover-Konfiguration gespeichert.",
            "success"
          );
          await pause(3000);
        } catch (error) {
          const retry = await prompt(
            clc.yellow("\nM√∂chtest Du die Daten korrigieren? (") +
              clc.green("ja") +
              clc.yellow("/") +
              clc.red("nein") +
              clc.yellow("): ")
          );
          if (retry.toLowerCase() === "ja") {
            env.PUSHOVER_USER_KEY = await prompt(
              clc.cyan("\nPushover-Benutzer-Schl√ºssel: ")
            );
            env.PUSHOVER_APP_TOKEN = await prompt(
              clc.cyan("Pushover-API-Token: ")
            );
            saveEnv(env);
          }
        }
      } else {
        displayMessage("\nVerbindungstest √ºbersprungen.", "info");
        saveEnv(env);
        displayMessage("üìÇ Pushover-Konfiguration gespeichert.", "success");
        await pause(3000);
        testApiSuccess = true;
      }
    }
  } else {
    displayMessage("‚úÖ Pushover ist bereits konfiguriert.", "success");
    await pause(3000);
  }

  displayMessage("\nüõ†Ô∏è Verwalte TestFlight-URLs:", "info");
  await manageURLs(env.PUSHOVER_USER_KEY, env.PUSHOVER_APP_TOKEN);

  displayMessage("\n‚úÖ Setup abgeschlossen!", "success");
})();

async function pause(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function clearConsole() {
  process.stdout.write("\x1Bc");
}
